package main

import (
	"fmt"
	"math/rand"
	"time"
)

/*
Разработать программу, которая будет последовательно отправлять значения в
канал, а с другой стороны канала — читать. По истечению N секунд программа
должна завершаться.
*/

const (
	min = 0   // Минимальное значение для генерации случайных чисел
	max = 100 // Максимальное значение для генерации случайных чисел
)

func main() {
	// Инициализация генератора случайных чисел с использованием текущего времени
	rand.New(rand.NewSource(time.Now().UnixNano()))

	var timeToWork int              // Переменная для хранения времени работы в секундах
	_, err := fmt.Scan(&timeToWork) // Считывание времени работы из ввода
	if err != nil {
		return // Если произошла ошибка, выходим из функции
	}

	// Создание таймера, который сработает через указанное количество секунд
	timer := time.After(time.Duration(timeToWork) * time.Second)

	// Создание канала для передачи случайных чисел
	val := make(chan int, 1)
	defer close(val) // Закрытие канала при выходе из функции main

	// Создание канала для остановки горутины
	stop := make(chan bool, 1)

	// Запуск горутины для чтения значений из канала val
	go func(val chan int) {
		for {
			select {
			case <-stop: // Если получен сигнал остановки
				fmt.Println("чтение горутин остановлено") // Сообщение о завершении работы горутины
				return                                    // Выход из горутины
			default:
				// Чтение значения из канала val и его вывод
				fmt.Printf("val = %d\n", <-val)
			}
		}
	}(val)

	// Основной цикл, который генерирует случайные числа
	for {
		select {
		case <-timer: // Если таймер сработал
			fmt.Printf("поток main остановлен\n%d val в main канале", len(val)) // Сообщение о завершении работы основного потока
			stop <- true                                                        // Отправка сигнала остановки горутине
			return                                                              // Выход из функции main
		default:
			// Генерация случайного числа и отправка его в канал val
			val <- rand.Intn(max-min) + min
			time.Sleep(time.Second) // Пауза на 1 секунду перед следующей итерацией
		}
	}
}
